{
	"common": {
		"title": "estructuradatos.org",
		"home": "Home",
		"dataStructures": "Data Structures",
		"applications": "Applications",
		"stack": "Stack",
		"queue": "Queue",
		"linkedList": "Linked List",
		"binaryTree": "Binary Search Tree",
		"avlTree": "AVL Tree",
		"heap": "Heap",
		"dijkstra": "Dijkstra's Algorithm",
		"messageQueue": "Message Queue",
		"polynomial": "Polynomial Multiplication",
		"computerVision": "Computer Vision Learning",
		"visualization": "Visualization",
		"explanation": "Explanation",
		"settings": "Settings",
		"language": "Language",
		"spanish": "Spanish",
		"english": "English",
		"dashboard": "Dashboard",
		"analysis": "Analysis",
		"size": "Size",
		"empty": "Empty",
		"full": "Full"
	},
	"controls": {
		"stackControls": "Stack Controls",
		"queueControls": "Queue Controls",
		"listControls": "List Controls",
		"heapControls": "Heap Controls",
		"enterValue": "Enter value",
		"push": "Push",
		"pop": "Pop",
		"clear": "Clear",
		"enqueue": "Enqueue",
		"dequeue": "Dequeue",
		"insert": "Insert",
		"insertNode": "Insert Node",
		"insertAtFront": "Insert at Front",
		"deleteFront": "Delete Front",
		"deleteBack": "Delete Back",
		"reverseList": "Reverse List",
		"traversalControls": "Traversal Controls",
		"traversalHistory": "Traversal History",
		"operationHistory": "Operation History",
		"rotationHistory": "Rotation History",
		"inOrder": "In-Order",
		"preOrder": "Pre-Order",
		"postOrder": "Post-Order",
		"singleInsert": "Single Insert",
		"bulkInsert": "Bulk Insert (comma-separated)",
		"bulkInsertPlaceholder": "e.g., 1, 2, 3, 4",
		"insertAll": "Insert All",
		"clearHeap": "Clear Heap",
		"maxHeap": "Max Heap",
		"minHeap": "Min Heap",
		"buildGraph": "Build Graph",
		"algorithm": "Algorithm",
		"exampleGraphs": "Example Graphs",
		"loadPredefined": "Load a predefined graph",
		"selectExample": "Select an example",
		"manualBuild": "Manual Build",
		"addNodesEdges": "Add nodes and edges",
		"addRandomNode": "Add Random Node",
		"sourceNodeId": "Source node ID",
		"targetNodeId": "Target node ID",
		"edgeWeight": "Edge weight",
		"addEdge": "Add Edge",
		"findShortestPath": "Find Shortest Path",
		"startNode": "Start Node",
		"endNode": "End Node",
		"nodeId": "Node ID",
		"previous": "Previous",
		"next": "Next",
		"currentPath": "Current Path",
		"pathDetails": "Path details and distance",
		"path": "Path",
		"totalDistance": "Total Distance",
		"noPathFound": "No path found yet",
		"clickFindPath": "Click 'Find Shortest Path' to start",
		"foundPathEdges": "Found path with {{count}} edges",
		"clearGraph": "Clear Graph",
		"step": "Step {{current}} of {{total}}",
		"configureRun": "Configure and run the algorithm"
	},
	"stack": {
		"description": "A Last-In-First-Out (LIFO) data structure with push and pop operations."
	},
	"queue": {
		"description": "A First-In-First-Out (FIFO) data structure with enqueue and dequeue operations."
	},
	"linkedList": {
		"description": "A dynamic data structure with nodes connected via references."
	},
	"binaryTree": {
		"description": "A hierarchical tree where each node has at most two children."
	},
	"avlTree": {
		"description": "A self-balancing binary search tree."
	},
	"heap": {
		"description": "A complete tree that satisfies the heap property (max or min).",
		"maxDescription": "A complete tree that satisfies the heap property (max or min).",
		"minDescription": "A complete tree that satisfies the heap property (min or max).",
		"maxTitle": "Max Heap",
		"minTitle": "Min Heap",
		"arrayRepresentation": "Array Representation"
	},
	"dijkstra": {
		"description": "Algorithm for finding the shortest paths between nodes in a graph."
	},
	"cv": {
		"title": "Computer Vision Learning",
		"description": "Learn data structures using hand gestures and interact with 3D visualizations!",
		"loadingMediaPipe": "Loading MediaPipe...",
		"startCamera": "Start Camera",
		"stopCamera": "Stop Camera",
		"openHand": "Open Hand",
		"fist": "Fist",
		"statistics": "Statistics",
		"stackSize": "Stack Size",
		"instructions": "Instructions",
		"instructionPush": "Open your hand to add (PUSH) a random value to the stack.",
		"instructionPop": "Close your hand into a fist to remove (POP) the top value.",
		"instructionWait": "Wait 1.5 seconds between gestures.",
		"recentHistory": "Recent History"
	},
	"feedback": {
		"running": "Running...",
		"complete": "Complete",
		"current": "Current",
		"time": "Time",
		"space": "Space",
		"showMore": "Show more",
		"showLess": "Show less",
		"steps": "steps",
		"showAllSteps": "Show all ({{count}} steps)",
		"performOperation": "Perform an operation to see step-by-step feedback",
		"checkOverflow": "Check for Overflow",
		"checkOverflowDesc": "Verify if stack has space. Current size: {{size}}, checking if full...",
		"incrementTop": "Increment Top Pointer",
		"incrementTopDesc": "Move top pointer from {{from}} to {{to}}",
		"assignValue": "Assign Value",
		"assignValueDesc": "Store value {{value}} at position stack[{{pos}}]",
		"pushComplete": "Push Complete",
		"pushCompleteDesc": "Value {{value}} successfully added to the stack. New size: {{size}}",
		"checkUnderflow": "Check for Underflow",
		"checkUnderflowDesc": "Verify if stack has elements. Current size: {{size}}",
		"retrieveValue": "Retrieve Value",
		"retrieveValueDesc": "Get value {{value}} from position stack[{{pos}}]",
		"decrementTop": "Decrement Top Pointer",
		"decrementTopDesc": "Move top pointer from {{from}} to {{to}}",
		"popComplete": "Pop Complete",
		"popCompleteDesc": "Value {{value}} successfully removed. New size: {{size}}",
		"checkFull": "Check if Queue is Full",
		"checkFullDesc": "Verify queue has space. Current size: {{size}}",
		"incrementRear": "Increment Rear Pointer",
		"incrementRearDesc": "Move rear pointer to position {{pos}}",
		"enqueueComplete": "Enqueue Complete",
		"enqueueCompleteDesc": "Value {{value}} added to queue. New size: {{size}}",
		"checkEmpty": "Check if Queue is Empty",
		"checkEmptyDesc": "Verify queue has elements. Current size: {{size}}",
		"retrieveFront": "Retrieve Front Value",
		"retrieveFrontDesc": "Get value {{value}} from front of queue",
		"incrementFront": "Increment Front Pointer",
		"incrementFrontDesc": "Move front pointer to next element",
		"dequeueComplete": "Dequeue Complete",
		"dequeueCompleteDesc": "Value {{value}} removed. New size: {{size}}",
		"startInsertion": "Start Insertion",
		"startInsertionDesc": "Inserting value {{value}} into the BST",
		"compareWith": "Compare with {{value}}",
		"compareWithDesc": "{{value1}} {{op}} {{value2}}, go {{direction}}",
		"insertionComplete": "Insertion Complete",
		"insertionCompleteDesc": "Value {{value}} inserted successfully after {{count}} comparisons",
		"createNode": "Create New Node",
		"createNodeDesc": "Allocate memory for new node with value {{value}}",
		"linkNext": "Link to Current Head",
		"linkNextDesc": "Point new node's next to current head",
		"updateHead": "Update Head Pointer",
		"updateHeadDesc": "Make new node the head",
		"insertComplete": "Insert Complete",
		"insertCompleteDesc": "Node with value {{value}} is now the head",
		"traverseEnd": "Traverse to End",
		"traverseEndDesc": "Navigate through {{count}} nodes to find tail",
		"linkNode": "Link New Node",
		"linkNodeDesc": "Connect tail to new node",
		"insertBackComplete": "Insert Complete",
		"insertBackCompleteDesc": "Node with value {{value}} added at the end",
		"checkRelaxation": "Check Relaxation Condition",
		"checkRelaxationDesc": "Is distance[{{from}}] + {{weight}} < distance[{{to}}]?",
		"updateDistance": "Update Distance",
		"updateDistanceDesc": "Update distance to {{to}} from {{oldDist}} to {{newDist}}",
		"updateParent": "Update Parent",
		"updateParentDesc": "Set parent of {{to}} to {{from}} for path reconstruction",
		"left": "left",
		"right": "right"
	},
	"visualizer": {
		"stackEmpty": "Stack Empty",
		"stackEmptyHint": "Use the controls to add elements",
		"queueEmpty": "Queue Empty",
		"queueEmptyHint": "Add elements with Enqueue",
		"listEmpty": "List Empty",
		"listEmptyHint": "Insert nodes to begin",
		"treeEmpty": "Tree Empty",
		"treeEmptyHint": "Insert nodes to build the tree",
		"topLabel": "TOP →",
		"frontLabel": "FRONT",
		"rearLabel": "REAR",
		"headLabel": "HEAD",
		"tailLabel": "TAIL"
	},
	"analysis": {
		"totalNodes": "Total Nodes",
		"height": "Height",
		"leafNodes": "Leaf Nodes",
		"internalNodes": "Internal Nodes",
		"fullNodes": "Full Nodes",
		"isBalanced": "Is Balanced",
		"isValidBST": "Is Valid BST",
		"minValue": "Min Value",
		"maxValue": "Max Value",
		"yes": "Yes",
		"no": "No",
		"basicProperties": "Basic Properties",
		"coreCharacteristics": "Core tree characteristics",
		"structureAnalysis": "Structure Analysis",
		"treeOrganization": "Tree organization details",
		"bstProperties": "BST Properties",
		"bstValidation": "Binary Search Tree validation",
		"graphStructure": "Graph Structure",
		"basicGraphMetrics": "Basic graph metrics",
		"nodes": "Nodes",
		"edges": "Edges",
		"averageDegree": "Average Degree",
		"algorithmProgress": "Algorithm Progress",
		"currentSearchStatus": "Current search status",
		"visitedNodes": "Visited Nodes",
		"remainingNodes": "Remaining Nodes",
		"progress": "Progress",
		"pathAnalysis": "Path Analysis",
		"shortestPathDetails": "Shortest path details",
		"pathLength": "Path Length",
		"totalDistance": "Total Distance",
		"path": "Path",
		"edgesCount": "edges",
		"none": "None",
		"noData": "No tree data available. Insert some nodes to see the analysis.",
		"balanceAnalysis": "Balance Analysis",
		"avlBalance": "AVL tree balance properties",
		"isAvlBalanced": "Is AVL Balanced",
		"perfectlyBalanced": "Perfectly Balanced",
		"balanceFactors": "Balance Factors",
		"valueRange": "Value Range"
	},
	"landing": {
		"heroTitle": "Visualizador ES",
		"heroDescription": "Learn data structures with 3D visualizations, real-time analysis, and interactive examples.",
		"viewOnGithub": "View on GitHub",
		"goToVisualizer": "Visualizer",
		"featuresTitle": "Interactive Learning Tools",
		"featuresDescription": "Explore structures and applications with step-by-step controls, analysis, and practice.",
		"featuresBadge": "Features",
		"closePreview": "Close Preview",
		"tryItOut": "Try it out",
		"stackDesc": "LIFO data structure with push and pop operations",
		"queueDesc": "FIFO data structure with enqueue and dequeue operations",
		"linkedListDesc": "Linear data structure with elements linked using pointers",
		"bstDesc": "Basic binary tree with BST properties",
		"avlDesc": "Self-balancing binary search tree with O(log n) time complexity",
		"heapDesc": "Priority queue implemented using a binary tree with heap properties",
		"messageQueueDesc": "Use a message queue to simulate a producer-consumer system",
		"polynomialDesc": "See polynomial multiplication in action using linked list representation",
		"dijkstraDesc": "Find the shortest path between nodes in a graph",
		"computerVisionDesc": "Learn data structures using hand gestures and computer vision",
		"techStackBadge": "Tech Stack",
		"techStackTitle": "Built with Next.js 15.1.2 and TypeScript 5",
		"techStackDescription": "3D engine with Three.js and React Three Fiber, smooth animations, and modern UI.",
		"techCardNextTitle": "Next.js 15.1.2 + React 19",
		"techCardNextDesc": "App Router and hybrid rendering for consistent performance.",
		"techCardThreeTitle": "Three.js 0.182 + R3F 9.5 + Drei 10.7",
		"techCardThreeDesc": "3D scenes with declarative camera, lights, and controls.",
		"techCardAnimationsTitle": "Animations",
		"techCardAnimationsDesc": "@react-spring/three 10.0 and Framer Motion 11.15.",
		"techCardUiTitle": "UI and i18n",
		"techCardUiDesc": "TailwindCSS 3.4, shadcn/ui, and i18next 25.7.",
		"ctaTitle": "Ready to start learning?",
		"ctaDescription": "Explore data structures with interactive visualizations and guided exercises.",
		"ctaButton": "Start now"
	},
	"orgLanding": {
		"heroTitle": "estructuradatos.org",
		"heroSubtitle": "Nonprofit tech organization",
		"heroDescription": "Open source, free resources to learn programming and data structures with a practical focus.",
		"heroPrimaryCta": "Explore Visualizador ES",
		"heroSecondaryCta": "View on GitHub",
		"missionBadge": "Our mission",
		"missionTitle": "Open and accessible learning",
		"missionDescription": "We offer free content for students and educators with interactive tools that simplify learning.",
		"value1Title": "Open education",
		"value1Description": "Reusable, free content for the education community.",
		"value2Title": "Open Source",
		"value2Description": "Transparent code to review, improve, and reuse.",
		"value3Title": "Educational impact",
		"value3Description": "Purpose-driven technology to democratize learning.",
		"openSourceTitle": "Transparency and continuous improvement",
		"openSourceDescription": "All projects live on GitHub and are built collaboratively.",
		"openSourceCta": "Explore repository",
		"aboutCta": "Learn more",
		"projectsBadge": "Projects",
		"projectsTitle": "Open source projects to learn data structures",
		"projectsDescription": "Explore Visualizador ES and Pac-Man Data Lab: interactive experiences with animation, analysis, and real data structures.",
		"projectCardTitle": "Visualizador ES",
		"projectCardDescription": "Learn data structures with simulations, analysis, and guided exercises.",
		"projectCardBullet1": "3D visualizations and step-by-step animations",
		"projectCardBullet2": "Real-time analysis and educational metrics",
		"projectCardBullet3": "Interactive examples and practical applications",
		"projectCardPrimaryCta": "View visualizer landing",
		"projectCardSecondaryCta": "Go to visualizer",
		"pacmanCardTitle": "Pac-Man Data Lab",
		"pacmanCardDescription": "Retro educational game with maze logic, ghost AI, and tick-based animation.",
		"pacmanCardBullet1": "2D matrix map for O(1) collision checks",
		"pacmanCardBullet2": "Queues and BFS for shortest-path chasing",
		"pacmanCardBullet3": "Game state machine and real-time power mode",
		"pacmanCardPrimaryCta": "Play Pac-Man",
		"pacmanCardSecondaryCta": "View project code",
		"communityTitle": "Open community",
		"communityDescription": "Contribute improvements, reports, or new ideas to expand the educational reach.",
		"communityCta": "Contribute on GitHub",
		"navMission": "Mission",
		"navOpenSource": "Open Source",
		"navProjects": "Projects",
		"navCommunity": "Community",
		"navProjectLink": "Visualizador ES",
		"navPacmanLink": "Pac-Man Data Lab"
	},
	"footer": {
		"educationalProject": "Educational project",
		"course": "Data Structures Subject",
		"faculty": "Faculty of Life Sciences and Technologies",
		"methodology": "Methodology: practice-based learning with 3D simulations and real-time analysis.",
		"creator": "Creator: Ing. Israel J. Gomez, Mgtr.",
		"contribution": "New version contribution: Ing. Israel J. Gomez, Mgtr.",
		"about": "About",
		"originalRepo": "Based on dsa-visualizer"
	},
	"about": {
		"title": "About the Project",
		"methodology": "Methodology",
		"institution": "Institution",
		"credits": "Credits",
		"contribution": "Project contribution: Ing. Israel J. Gomez, Mgtr.",
		"students": "Students of 3rd Level Parallel C Data Structures Subject & Instructor"
	},
	"messageQueue": {
		"title": "Message Queue",
		"description": "A queue-based system to handle asynchronous message processing between producers and consumers.",
		"producers": "Producers",
		"consumers": "Consumers",
		"messagesWaiting": "{{count}} messages waiting",
		"processed": "{{count}} processed",
		"currentlyProcessing": "Currently Processing",
		"processingBy": "{{name}} is processing...",
		"producerLabel": "Producer {{index}}",
		"consumerLabel": "Consumer {{index}}",
		"enterMessage": "Enter message",
		"send": "Send",
		"processedMessages": "Processed Messages",
		"completed": "{{count}} completed",
		"status": {
			"pending": "pending",
			"processing": "processing",
			"completed": "completed",
			"failed": "failed"
		}
	},
	"polynomial": {
		"title": "Polynomial Multiplication",
		"description": "Visualize polynomial multiplication using linked lists.",
		"multiply": "Multiply",
		"controlsTitle": "Polynomial Controls",
		"operationHistory": "Operation History",
		"result": "Result",
		"startMultiplication": "Start Multiplication",
		"previousStep": "Previous Step",
		"nextStep": "Next Step",
		"autoPlay": "Auto Play",
		"pause": "Pause",
		"firstPolynomial": "First Polynomial",
		"secondPolynomial": "Second Polynomial",
		"setPolynomials": "Set Polynomials",
		"useExample": "Use Example",
		"polynomialPlaceholder": "e.g. x + 2"
	},
	"pacman": {
		"title": "PAC-MAN DATA LAB",
		"subtitle": "Interactive data structure visualization",
		"subtitleLong": "Learn data structures while playing. Watch algorithms work in real time.",
		"coreState": "Core State",
		"playing": "PLAYING",
		"paused": "PAUSED",
		"victory": "VICTORY",
		"gameOver": "GAME OVER",
		"energy": "Energy",
		"units": "Lives",
		"dataScore": "Data Score",
		"cinemaMode": "CINEMA MODE",
		"windowMode": "WINDOW MODE",
		"resumeThread": "RESUME THREAD",
		"restartCore": "RESTART CORE",
		"controls": "CONTROLS: WASD / ARROWS",
		"inputMap": "Controls",
		"memoryUnits": "Game Objective",
		"memoryDesc": "Collect all memory nodes (pellets). Ghosts use BFS to chase you.",
		"iaMonitor": "Learning Monitor",
		"active": "ACTIVE",
		"techArch": "Tech Architecture",
		"matrices2d": "2D Matrices",
		"matricesDesc": "The maze is a 2D matrix where each cell represents a tile type (wall, empty, pellet).",
		"bfsAlgo": "BFS Algorithm",
		"bfsDesc": "Ghosts use Breadth-First Search to find the shortest path to Pac-Man.",
		"pathfinding": "Pathfinding",
		"pathfindingDesc": "Each walkable cell is a node in the graph, connected to its 4 adjacent neighbors.",
		"fsmLogic": "FSM Logic",
		"fsmDesc": "A Finite State Machine controls behavior: CHASE, SCATTER, FRIGHTENED.",
		"openSourceLab": "OPEN SOURCE LAB",
		"dataStructs1": "DATA STRUCTURES I",
		"bufferOverrun": "Buffer Overrun Detected",
		"compilationSuccess": "Compilation Success",
		"zeroErrors": "Zero Errors - High Score",
		"breakPoint": "Break Point",
		"executionSuspended": "Execution Suspended",
		"liveState": "Real-Time State",
		"position": "Position",
		"currentCell": "Current Cell",
		"ghostMode": "Ghost Mode",
		"chase": "CHASE",
		"scatter": "SCATTER",
		"frightened": "FRIGHTENED",
		"pelletsRemaining": "Pellets Remaining",
		"conceptHighlight": "Highlighted Concept",
		"conceptMatrix": "O(1) matrix access: maze[{{y}}][{{x}}] returns the cell type instantly.",
		"conceptBfs": "BFS explores level by level, guaranteeing the shortest path is found.",
		"conceptFsm": "Current state determines behavior: chase, flee, or scatter.",
		"conceptQueue": "BFS queue processes nodes in FIFO order for level-by-level exploration.",
		"howItWorks": "How Does It Work?",
		"matrixExplain": "The maze is stored as number[][] where 0=empty, 1=wall, 2=pellet, 3=power pellet.",
		"bfsExplain": "Each tick, ghosts calculate the shortest path using a queue and a visited set.",
		"fsmExplain": "Game state changes: eating a power pellet triggers FRIGHTENED mode for ghosts.",
		"startToLearn": "Press SPACE to start and watch the algorithms in action.",
		"iaComments": {
			"pelletEaten": "O(1) matrix access: maze[y][x] checked and updated to EMPTY.",
			"powerPellet": "FSM: State transition CHASE → FRIGHTENED activated.",
			"ghostClose": "BFS calculating route: Queue with {{count}} nodes in frontier.",
			"ghostEaten": "Collision detected in FRIGHTENED mode: ghost neutralized.",
			"collision": "System error: Collision with ghost process in CHASE mode.",
			"victory": "All memory nodes collected. Algorithm completed.",
			"idle": "System idle. Press SPACE to start execution."
		}
	}
}
